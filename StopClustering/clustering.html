<html>
<head>
	<title>Refinement</title>
	<script src="d3.min.js" charset="utf-8"></script>
	<style>
		body {
			background-color: papayawhip;
			text-align: center;
		}

		svg {
			background-color: white;
		}

		path {
			fill: none;
			stroke: black;
			stroke-width: 5px;
		}

		circle {
			cursor: pointer;
		}

		.cluster circle {
			fill: none;
			stroke: black;
			stroke-width: 5px;
		}
	</style>
</head>
<body>
	<h1>Stop clustering</h1>
	<svg width="800" height="800"></svg>
	<script>
		var svg = d3.select('svg');
		svg.clusters = svg.append('g').attr('class', 'cluster');
		svg.points = svg.append('g');
		svg.points.drag = d3.behavior.drag();
		svg.points.drag
			.on('drag', function (d)
			{
				var coords = d3.mouse(this);
				d[0] = coords[0];
				d[1] = coords[1];
				update();
			})
		;

		svg
			.on('click', function (d)
			{
				if (d3.event.defaultPrevented) return;
				points.push(d3.mouse(this));
				update();
			})
		;

		var points = [];
		function updatePoints()
		{
			var g = svg.points.selectAll('circle').data(points);
			g.enter().append('circle')
				.attr('r', 10)
				.call(svg.points.drag)
			;
			g
				.attr('cx', function (d) { return d[0]; })
				.attr('cy', function (d) { return d[1]; })
			;
			g.exit().remove();
		}

		var clusters = [];
		function updateClusters()
		{
			var g = svg.clusters.selectAll('circle').data(clusters);
			g.enter().append('circle');
			g
				.attr('cx', function (d) { return d.center[0]; })
				.attr('cy', function (d) { return d.center[1]; })
				.attr('r',  function (d) { return d.radius; })
			;
			g.exit().remove();
		}

		function update()
		{
			function extract(node)
			{
				if (!Array.isArray(node))
					return [points[node]];
				var coords = [].concat(extract(node[0])).concat(extract(node[1]));
				clusters.push(fast_enclosing_circle(coords));
				return coords;
			}
			clusters = [];
			var c = cluster(points, function (a, b)
			{
				a = points[a];
				b = points[b];
				return distance(a[0], a[1], b[0], b[1])/* - a.radius - b.radius*/;
			});
			if (points.length > 2)
				extract(c);
			updatePoints();
			updateClusters();
		}

		function distance(x1, y1, x2, y2)
		{
			var vx = x2 - x1,
				vy = y2 - y1;
			return Math.sqrt(vx * vx + vy * vy);
		}

		function Forest(range)
		{
			this.clusters = Array(range);
		}

		Forest.prototype.find = function (a)
		{
			var parent = this.clusters;
			if (parent[a] === undefined)
				return parent[a] = a;
			if (parent[a] != a)
				parent[a] = this.find(parent[a]);
			return parent[a];
		}

		Forest.prototype.union = function (a, b)
		{
			a = this.find(a);
			b = this.find(b);
			this.clusters[b] = a;
			return a != b;
		}

		function fast_enclosing_circle(circles)
		{
			circles = circles.map(function (circle)
			{
				if (Array.isArray(circle))
					return [circle[0], circle[1], 0];
				else
					return [circle.center[0], circle.center[1], circle.radius];
			});

			if (circles.length < 2)
				return { center: [circles[0][0], circles[0][1]], radius: circles[0][2] };
				
			var x = circles[(circles.length * Math.random()) << 0],
				y = extract_furthest(circles, x),
				z = extract_furthest(circles, y),
				circle = enclose(y, z);

			while (circles.length)
				circle = enclose(circle, circles.pop());

			return { center: [circle[0], circle[1]], radius: circle[2] };
		}

		function extract_furthest(circles, x)
		{
			var y = undefined,
				j = undefined,
				max = -Infinity;
			for (var i = circles.length - 1; i >= 0; --i)
			{
				if (circles[i] == x) continue;
				var d = distance(x[0], x[1], circles[i][0], circles[i][1]);
				if (d > max)
				{
					y = circles[i];
					j = i;
					max = d;
				}
			}
			circles.splice(j, 1);
			return y;
		}

		function enclose(c1, c2)
		{
			var vx = c2[0] - c1[0],
				vy = c2[1] - c1[1],
				rs = c1[2] + c2[2],
				d = distance(c1[0], c1[1], c2[0], c2[1]);
			if (d <= rs) return c1;
			var r = (d + rs) / 2,
				cx = c1[0] + vx * (r - c1[2]) / d,
				cy = c1[1] + vy * (r - c1[2]) / d;
			return [cx, cy, r];
		}

		function cluster(coords, distfunc)
		{
			var tri = d3.geom.delaunay(coords),
				edges = [],
				forest = new Forest(coords.length),
				forest2 = [],
				tree = undefined;

			console.log(tri)

			tri.forEach(function (triangle)
			{
				triangle[0] = coords.indexOf(triangle[0]);
				triangle[1] = coords.indexOf(triangle[1]);
				triangle[2] = coords.indexOf(triangle[2]);
			});

			for (var i = tri.length - 1; i >= 0; --i)
			{
				var t = tri[i];
				if (t[1] > t[0]) edges.push([t[0], t[1], distfunc(t[0], t[1])]);
				if (t[2] > t[1]) edges.push([t[1], t[2], distfunc(t[1], t[2])]);
				if (t[0] > t[2]) edges.push([t[2], t[0], distfunc(t[2], t[0])]);
			}
			edges.sort(function (a, b) { return b[2] - a[2]; });
			tri = null;

			while (edges.length)
			{
				var edge = edges.pop(),
					u = forest.find(edge[0]),
					v = forest.find(edge[1]);
				if (forest.union(u, v))
				{
					tree = forest2[u] = [
						forest2[u] || edge[0],
						forest2[v] || edge[1],
						edge[2]
					];
					if (v in forest2)
						delete forest2[v];
				}
			}
			forest = null;
			forest2.length = 0;

			return tree;
		}

	</script>
</body>
</html>